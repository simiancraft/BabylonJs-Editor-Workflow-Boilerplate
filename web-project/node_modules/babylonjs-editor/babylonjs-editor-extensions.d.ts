// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../babylonjs
//   ../../../litegraph.js

declare module 'babylonjs-editor' {
    import Extensions from 'babylonjs-editor/extensions';
    import Extension from 'babylonjs-editor/extension';
    import AssetsExtension from 'babylonjs-editor/assets/assets';
    import CodeExtension from 'babylonjs-editor/behavior/code';
    import GraphExtension, { LGraph, LGraphCanvas, LiteGraph, LiteGraphNode, LGraphGroup } from 'babylonjs-editor/behavior/graph';
    import PathFinderExtension from 'babylonjs-editor/path-finder/index';
    import PostProcessEditorExtension from 'babylonjs-editor/post-process-editor/post-process-editor';
    import MaterialEditorExtension from 'babylonjs-editor/material-editor/material-editor';
    import PostProcessExtension from 'babylonjs-editor/post-process/post-processes';
    import CustomMetadatasExtension from 'babylonjs-editor/metadata/metadatas';
    import { IExtension, ExtensionConstructor } from 'babylonjs-editor/typings/extension';
    export { Extensions, Extension, AssetsExtension, CodeExtension, GraphExtension, LGraph, LGraphCanvas, LiteGraph, LiteGraphNode, LGraphGroup, PostProcessExtension, MaterialEditorExtension, PathFinderExtension, PostProcessEditorExtension, CustomMetadatasExtension, IExtension, ExtensionConstructor };
}

declare module 'babylonjs-editor/extensions' {
    import { Scene } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import { IExtension, ExtensionConstructor } from 'babylonjs-editor/typings/extension';
    import Tools from 'babylonjs-editor/tools/tools';
    import Mobile from 'babylonjs-editor/tools/mobile';
    export default class Extensions {
            static Extensions: IStringDictionary<ExtensionConstructor<any>>;
            static Instances: IStringDictionary<IExtension<any>>;
            static OrderedExtensions: string[];
            static Tools: Tools;
            static Mobile: Mobile;
            static RoolUrl: string;
            /**
                * Registers an extension
                * @param extension the extension to register
                */
            static Register<T>(name: string, extension: ExtensionConstructor<T>): boolean;
            /**
                * Requests an extension: returns the already created
                * if already exists
                * @param name the name of the extension
                */
            static RequestExtension<T extends IExtension<any>>(scene: Scene, name: string): T;
            /**
                * Applies all extesions giving all the custom metadatas
                * @param metadatas the metadatas for all extensions
                */
            static ApplyExtensions(scene: Scene, metadatas: IStringDictionary<any>): void;
            /**
                * Clears all the extensions
                */
            static ClearExtensions(): void;
    }
}

declare module 'babylonjs-editor/extension' {
    import { Scene } from 'babylonjs';
    import { IExtension } from 'babylonjs-editor/typings/extension';
    export default abstract class Extension<T> implements IExtension<T> {
            scene: Scene;
            datas: T;
            alwaysApply: boolean;
            /**
                * Constructor
                * @param scene: the scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            abstract onApply(data: T, rootUrl?: string): void;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            abstract onLoad(data: T): void;
            /**
                * Adds a script tag element to the dom including source URL
                * @param code: the code's text
                * @param url: the URL of the script to show in devtools
                */
            static AddScript(code: string, url: string): HTMLScriptElement;
    }
}

declare module 'babylonjs-editor/assets/assets' {
    import { Node, Scene, ParticleSystemSet, Vector3 } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { AssetElement } from 'babylonjs-editor/typings/asset';
    /**
        * Assets type used as alias
        */
    export interface ProjectAssets {
            prefabs: AssetElement<any>[];
            particles: AssetElement<any>[];
    }
    export default class AssetsExtension extends Extension<ProjectAssets> {
            prefabs: AssetElement<any>[];
            particles: AssetElement<any>[];
            /**
                * Constructor
                * @param scene the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: ProjectAssets): void;
            /**
                * Instantiate a prefab identified by the given name
                * @param name the name of the prefab to instantiate
                */
            instantiatePrefab<T extends Node>(name: string): T;
            /**
                * Instantiates a particle system set identified by the given name
                * @param name the name of the particle system set to instantiate
                * @param position the position where to start systems
                */
            instantiateParticleSystemsSet(name: string, position?: Vector3): ParticleSystemSet;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): ProjectAssets;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: ProjectAssets): void;
    }
}

declare module 'babylonjs-editor/behavior/code' {
    import { Scene, AbstractMesh } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import { IAssetComponent, AssetElement } from 'babylonjs-editor/typings/asset';
    import Extension from 'babylonjs-editor/extension';
    export interface BehaviorCode {
            code: string;
            compiledCode?: string;
            name: string;
            id: string;
    }
    export interface BehaviorNodeCode {
            codeId: string;
            active: boolean;
            params?: any;
    }
    export interface BehaviorNodeMetadata {
            node: string;
            nodeId: string;
            metadatas: BehaviorNodeCode[];
    }
    export interface BehaviorMetadata {
            scripts: BehaviorCode[];
            nodes: BehaviorNodeMetadata[];
    }
    export module EDITOR {
            class BehaviorCode {
                    static Constructors: {};
            }
    }
    export default class CodeExtension extends Extension<BehaviorMetadata> implements IAssetComponent {
            id: string;
            assetsCaption: string;
            instances: IStringDictionary<any>;
            scriptsConstructors: IStringDictionary<any>;
            objectsInstances: IStringDictionary<any[]>;
            static Instance: CodeExtension;
            static CurrentDatas: BehaviorMetadata;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * Creates a new code asset
                */
            onCreateAsset(name: string): Promise<AssetElement<any>>;
            /**
                * On the user renames the asset
                * @param asset the asset being renamed
                * @param name the new name of the asset
                */
            onRenameAsset(asset: AssetElement<BehaviorCode>, name: string): void;
            /**
                * On get all the assets to be drawn in the assets component
                */
            onGetAssets(): AssetElement<any>[];
            /**
                * On the user drops an asset
                * @param targetMesh the target mesh under the pointer
                * @param asset the asset being dropped
                */
            onDragAndDropAsset(targetMesh: AbstractMesh, asset: AssetElement<any>): void;
            /**
                * On the user wants to remove the asset
                * @param asset the asset to remove
                */
            onRemoveAsset(asset: AssetElement<any>): void;
            /**
                * On the user adds an asset
                * @param asset the asset to add
                */
            onAddAsset(asset: AssetElement<any>): void;
            /**
                * On apply the extension
                */
            onApply(data: BehaviorMetadata): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): BehaviorMetadata;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: BehaviorMetadata): void;
            /**
                * Sets the custom params
                * @param m the behavior code structure
                * @param instance the instance
                */
            setCustomParams(m: BehaviorNodeCode, instance: any): void;
            /**
                * Return the constructor
                * @param code the code metadata
                * @param node the attached node
                * @param evaluate if the script should just be evaluated instead of injected in DOM
                */
            getConstructor(code: BehaviorCode, node: any, evaluate?: boolean): any;
            /**
                * Returns the given object's constructor name
                * @param obj the instance
                */
            getConstructorName(obj: any): string;
            /**
                * Returns the final typescript code
                * @param code: the behavior code metadata
                * @param node: the attached node
                */
            getFinalTypeScriptCode(code: BehaviorCode, node: any): string;
    }
}

declare module 'babylonjs-editor/behavior/graph' {
    import { Scene, AbstractMesh } from 'babylonjs';
    import { LGraph, LGraphCanvas, LiteGraph, LGraphGroup } from 'litegraph.js';
    import Extension from 'babylonjs-editor/extension';
    import { AssetElement } from 'babylonjs-editor/typings/asset';
    import { LiteGraphNode } from 'babylonjs-editor/behavior/graph-nodes/typings';
    export { LGraph, LGraphCanvas, LiteGraph, LiteGraphNode, LGraphGroup };
    export interface GraphData {
            graph: any;
            name: string;
            id: string;
    }
    export interface NodeGraph {
            graphId: string;
            active: boolean;
    }
    export interface GraphNodeMetadata {
            node: string;
            nodeId: string;
            metadatas: NodeGraph[];
    }
    export interface BehaviorGraphMetadata {
            graphs: GraphData[];
            nodes: GraphNodeMetadata[];
    }
    export default class GraphExtension extends Extension<BehaviorGraphMetadata> {
            id: string;
            assetsCaption: string;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On get all the assets to be drawn in the assets component
                */
            onGetAssets(): AssetElement<any>[];
            /**
                * On the user wants to remove the asset
                * @param asset the asset to remove
                */
            onRemoveAsset(asset: AssetElement<any>): void;
            /**
                * On the user adds an asset
                * @param asset the asset to add
                */
            onAddAsset(asset: AssetElement<any>): void;
            /**
                * On the user drops an asset
                * @param targetMesh the target mesh under the pointer
                * @param asset the asset being dropped
                */
            onDragAndDropAsset(targetMesh: AbstractMesh, asset: AssetElement<any>): void;
            /**
                * On apply the extension
                */
            onApply(data: BehaviorGraphMetadata): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): BehaviorGraphMetadata;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: BehaviorGraphMetadata): void;
            /**
                * Clears all the additional nodes available for Babylon.js
                */
            static ClearNodes(): void;
            /**
                * Registers all the additional nodes available for Babylon.js
                * @param object the object which is attached
                */
            static RegisterNodes(object?: any): void;
    }
}

declare module 'babylonjs-editor/path-finder/index' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import PathFinder from 'babylonjs-editor/path-finder/path-finder';
    export interface PathFinderMetadata {
            name: string;
            size: number;
            rayHeight: number;
            rayLength: number;
            castMeshes: string[];
    }
    export default class PathFinderExtension extends Extension<PathFinderMetadata[]> {
            instances: IStringDictionary<PathFinder>;
            /**
                * Constructor
                * @param scene the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: PathFinderMetadata[]): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): PathFinderMetadata[];
            /**
                * On load the extension (called by the editor when loading a scene)
                */
            onLoad(data: PathFinderMetadata[]): void;
    }
}

declare module 'babylonjs-editor/post-process-editor/post-process-editor' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import AbstractPostProcessEditor from 'babylonjs-editor/post-process-editor/post-process';
    export interface PostProcessCreatorUserConfig {
            textures?: {
                    value: any;
                    name: string;
            }[];
            floats?: {
                    value: number;
                    name: string;
            }[];
            vectors2?: {
                    value: number[];
                    name: string;
            }[];
            vectors3?: {
                    value: number[];
                    name: string;
            }[];
    }
    export interface PostProcessCreatorMetadata {
            cameraName: string;
            preview: boolean;
            name: string;
            code: string;
            compiledCode?: string;
            pixel: string;
            config: string;
            userConfig: PostProcessCreatorUserConfig;
            id: string;
    }
    export module EDITOR {
            class PostProcessCreator {
                    static Constructors: {};
            }
    }
    export default class PostProcessEditorExtension extends Extension<PostProcessCreatorMetadata[]> {
            instances: IStringDictionary<any>;
            static Instance: PostProcessEditorExtension;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * Creates a new post-process
                * @param data: the data containing code, pixel, etc.
                */
            createPostProcess(data: PostProcessCreatorMetadata, rootUrl?: string): AbstractPostProcessEditor;
            /**
                * On apply the extension
                */
            onApply(data: PostProcessCreatorMetadata[], rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): PostProcessCreatorMetadata[];
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: PostProcessCreatorMetadata[]): void;
    }
}

declare module 'babylonjs-editor/material-editor/material-editor' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import CustomEditorMaterial from 'babylonjs-editor/material-editor/material';
    export interface MaterialCreatorUserConfig {
            textures?: {
                    value: any;
                    name: string;
            }[];
            floats?: {
                    value: number;
                    name: string;
            }[];
            vectors2?: {
                    value: number[];
                    name: string;
            }[];
            vectors3?: {
                    value: number[];
                    name: string;
            }[];
    }
    export interface MaterialCreatorMetadata {
            name: string;
            id?: string;
            code: string;
            compiledCode?: string;
            vertex: string;
            pixel: string;
            config: string;
            userConfig: MaterialCreatorUserConfig;
    }
    export module EDITOR {
            class MaterialCreator {
                    static Constructors: {};
            }
    }
    export default class MaterialEditorExtension extends Extension<MaterialCreatorMetadata[]> {
            instances: IStringDictionary<any>;
            static Instance: MaterialEditorExtension;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * Creates a new material
                * @param data: the data containing code, vertex, etc.
                */
            createMaterial(data: MaterialCreatorMetadata, rootUrl?: string): CustomEditorMaterial;
            /**
                * On apply the extension
                */
            onApply(data: MaterialCreatorMetadata[], rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): MaterialCreatorMetadata[];
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: MaterialCreatorMetadata[]): void;
    }
}

declare module 'babylonjs-editor/post-process/post-processes' {
    import { Scene, StandardRenderingPipeline, SSAO2RenderingPipeline, DefaultRenderingPipeline } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    export interface PostProcessMetadata {
            standard?: any;
            default?: any;
            ssao2?: any;
    }
    export default class PostProcessesExtension extends Extension<PostProcessMetadata> {
            standard: StandardRenderingPipeline;
            default: DefaultRenderingPipeline;
            ssao2: SSAO2RenderingPipeline;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: PostProcessMetadata, rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): PostProcessMetadata;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: PostProcessMetadata): void;
    }
}

declare module 'babylonjs-editor/metadata/metadatas' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    export interface CustomMetadatas {
            node: string;
            nodeId: string;
            metadatas: any;
    }
    export default class CustomMetadatasExtension extends Extension<CustomMetadatas[]> {
            /**
                * Constructor
                * @param scene the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: CustomMetadatas[]): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): CustomMetadatas[];
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: CustomMetadatas[]): void;
    }
}

declare module 'babylonjs-editor/typings/extension' {
    import { Scene } from 'babylonjs';
    import { IAssetComponent } from 'babylonjs-editor/typings/asset';
    /**
        * Interface representing an editor extension
        */
    export interface IExtension<T> extends IAssetComponent {
            /**
                * Sets if the extensions is always applied
                */
            alwaysApply: boolean;
            /**
                * On apply the extension
                */
            onApply(data: T, rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize?(): T;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad?(data: T): void;
    }
    export type ExtensionConstructor<T> = new (scene: Scene) => IExtension<T>;
}

declare module 'babylonjs-editor/typings/typings' {
    export interface IStringDictionary<T> {
        [index: string]: T;
    }
}

declare module 'babylonjs-editor/tools/tools' {
    import { Node, Scene, ParticleSystem, ParticleSystemSet, Vector3 } from 'babylonjs';
    import PathFinder from 'babylonjs-editor/path-finder/path-finder';
    export default class Tools {
            /**
                * Returns a custom material by giving its name
                * @param name the name of the custom material
                */
            getCustomMaterial(name: string): any;
            /**
                * Returns a custom script given by its object attached to
                * and the name of the script
                * @param object the object containing the script
                * @param name the name of the script
                */
            getCustomScript(object: string | Node | ParticleSystem | Scene, name: string): any;
            /**
                * Returns the constructor of a script which has the given name
                * @param name the name of the script
                */
            getConstructor(name: string): any;
            /**
                * Returns the post-process by giving its name
                * @param name the name of the post-process
                */
            getCustomPostProcess(name: string): any;
            /**
                * Returns a file given by its name
                * @param name the name of the file
                */
            getFileByName(name: string): File;
            /**
                * Returns an object url for the given file
                * @param filename the reachable by the created URL
                * @param oneTimeOnly if the URL should be requested only one time
                */
            getFileUrl(filename: string, oneTimeOnly?: boolean): string;
            /**
                * Returns the given path finder according to the given name
                * @param name the name of the path finder
                */
            getPathFinder(name: string): PathFinder;
            /**
                * Instantiates a prefab identified by the given name
                * @param name the name of the prefab to instantiate
                */
            instantiatePrefab<T extends Node>(name: string): T;
            /**
                * Instantiates a particle system set identified by the given name
                * @param name the name of the particle system set to instantiate
                * @param position the position where to start systems
                */
            instantiateParticleSystemSet(name: string, position?: Vector3): ParticleSystemSet;
            /**
                * Calls the given method with the given parameters on the given object which has scripts providing the given method
                * @param object the object reference where to send the message by calling the given method name
                * @param methodName the method name to call with the given parameters
                * @param params the parameters to send to the script attached to the given object
                */
            sendMessage(object: Node | ParticleSystem | Scene, methodName: string, ...params: any[]): void;
    }
    export const exportScriptString: string;
}

declare module 'babylonjs-editor/tools/mobile' {
    export default class Mobile {
        /**
          * Calls the navigator to vibrate with the given pattern
          * @param pattern the vibration pattern
          */
        vibrate(pattern: number | number[]): boolean;
    }
}

declare module 'babylonjs-editor/typings/asset' {
    import { AbstractMesh, PickingInfo } from 'babylonjs';
    export interface AssetElement<T> {
        img?: string;
        name?: string;
        data?: T;
        separator?: string;
    }
    export interface AssetContextMenu {
        id: string;
        text: string;
        img?: string;
        callback?: (asset?: AssetElement<any>) => void;
    }
    export interface IAssetComponent {
        id?: string;
        assetsCaption?: string;
        size?: number;
        onCreateAsset?(name: string): AssetElement<any> | Promise<AssetElement<any>>;
        onRenameAsset?(asset: AssetElement<any>, name: string): void;
        onGetAssets?(): AssetElement<any>[] | Promise<AssetElement<any>[]>;
        onRemoveAsset?(asset: AssetElement<any>): void;
        onAddAsset?(asset: AssetElement<any>): void;
        onDragAndDropAsset?(targetMesh: AbstractMesh, asset: AssetElement<any>, pickInfo?: PickingInfo): void;
        onDoubleClickAsset?(asset: AssetElement<any>): void;
        onContextMenu?(): AssetContextMenu[];
        onSerializeAssets?(): AssetElement<any>[];
        onParseAssets?(data: AssetElement<any>[]): void;
    }
}

declare module 'babylonjs-editor/behavior/graph-nodes/typings' {
    import { Node, Scene } from 'babylonjs';
    import { LGraph, LGraphCanvas } from 'litegraph.js';
    export abstract class LiteGraphNode {
            title: string;
            mode: number;
            color: string;
            bgColor: string;
            readonly type: string;
            properties: {
                    [index: string]: string | number | boolean;
            };
            outputs: {
                    name: string;
            }[];
            pos: number[];
            size: number[];
            shape: string;
            flags: any;
            graph: LGraph;
            protected _data: any;
            static desc: string;
            static LastCtor: new (addExecute?: boolean) => LiteGraphNode;
            static Loaded: boolean;
            /**
                * Constructor
                * @param addExecute if add an execute input
                */
            constructor(addExecute?: boolean);
            /**
                * On connections changed for this node
                * @param type input (1) or output (2)
                * @param slot the slot which has been modified
                * @param added if the connection is newly added
                */
            onConnectionsChange(type: any, slot: any, added: any): void;
            /**
                * Returns if the node has the given property defined
                * @param name the name of the property
                */
            hasProperty(name: string): boolean;
            /**
                * On the node is executed
                */
            onExecute?(): void;
            /**
                * On the node's action is executed
                */
            onAction?(): void;
            /**
                * Allowed methods
                */
            triggerSlot?(slot: number, data?: any): void;
            addInput?(type: string, name: string): void;
            addOutput?(name: string, type: string): void;
            getInputData?(slot: number, forceUpdate?: boolean): any;
            setOutputData?(slot: number, data: any): void;
            addProperty?(name: string, defaultValue: string | number | boolean): void;
            /**
                * On the background is drawn
                * @param ctx the canvas 2d context reference
                * @param text the text to draw
                */
            onDrawBackground(ctx: CanvasRenderingContext2D, graph: LGraphCanvas, canvas: HTMLCanvasElement, text?: string): void;
            onGetOutputs?(): string[][];
            onGetInputs?(): string[][];
            /**
                * Returns the target node
                * @param name the name of the node
                */
            protected getTargetNode(name: string): Node | Scene;
            /**
                * Register the node
                * @param location: the location in graph editor
                * @param ctor: the constructor of the node
                */
            static Register(location: string, ctor: new (addExecute?: boolean) => LiteGraphNode): void;
            /**
                * Sets the node's color
                * @param node the node to configure
                */
            static SetColor(node: LiteGraphNode): void;
    }
}

declare module 'babylonjs-editor/path-finder/path-finder' {
    import { Vector3, BoundingInfo, AbstractMesh, Animation } from 'babylonjs';
    export default class PathFinder {
            graph: Graph;
            width: number;
            height: number;
            buffer: number[][];
            points: Vector3[];
            availablePoints: Vector3[];
            protected boundingInfo: BoundingInfo;
            /**
                * Constructor
                * @param size the path finder grid size
                */
            constructor(size: number);
            /**
                * Rebuilds the path's finder buffer
                * NOTE: should be done before creating the graph
                * @param size the path finder grid size
                */
            rebuildBuffers(size: number): void;
            /**
                * Get Vector3 path from the given start position to the given
                * end position
                * @param from the start position (typically the position of the object to move)
                * @param to the end position (typically already known or pre-programmed)
                * @param optimize if the extension should optimize the animation to be linear
                */
            fromTo(from: Vector3, to: Vector3, optimize?: boolean): Vector3[];
            /**
                * Creates a new animation from the given path
                * @param name the animation name being created
                * @param path the path containing the path points
                * @param framesPerSecond frames per second for the animation
                */
            createAnimation(name: string, path: Vector3[], framesPerSecond?: number): Animation;
            /**
                * Returns the nearest point
                * @param point the point reference
                */
            findNearestPoint(point: Vector3): Vector3;
            /**
                * Fills the graph with the given mesh surface geometry using ray
                * casting method.
                * @param castMeshes: surface meshes (holes are supported)
                * @param rayHeight the height of the rays to test collisions
                * @param rayLength the length of the rays to test collisions
                */
            fill(castMeshes: AbstractMesh[], rayHeight?: number, rayLength?: number): void;
    }
}

declare module 'babylonjs-editor/post-process-editor/post-process' {
    import { PostProcess, Effect, Scene, Camera, BaseTexture, Engine, Vector2, Vector3 } from 'babylonjs';
    /**
        * The custom post-process code interface which
        * comes from the user
        */
    export interface CustomPostProcessCode {
            init: () => void;
            setUniforms: (uniforms: string[], samplers: string[]) => void;
            onApply: (effect: Effect) => void;
            dispose: () => void;
    }
    /**
        * Custom post-process config
        */
    export interface CustomPostProcessConfig {
            ratio: number;
            textures: string[];
            floats: string[];
            vectors2: string[];
            vectors3: string[];
    }
    export default class AbstractPostProcessEditor extends PostProcess {
            customCode: CustomPostProcessCode;
            config: CustomPostProcessConfig;
            userConfig: {
                    [index: string]: number | Vector2 | Vector3 | BaseTexture;
            };
            protected scene: Scene;
            protected additionalUniforms: string[];
            protected additionalSamplers: string[];
            /**
                * Constructor
                * @param name: the name of the post-process
                * @param fragmentUrl: the url of the fragment shader
                * @param camera: the camera to attach to
                * @param ratio: the ratio of the post-process
                * @param customCode: the custom code from user
                */
            constructor(name: string, fragmentUrl: string, camera: Camera, engine: Engine, config: CustomPostProcessConfig, customCode: CustomPostProcessCode);
            /**
                * Sets the .onApply property of the post-process
                */
            setOnApply(): void;
            /**
                * Sets the post-process config
                * @param config
                */
            setConfig(config: CustomPostProcessConfig): void;
            /**
                * Disposes the post-process
                */
            dispose(): void;
            /**
                * Returns the post-process class name
                */
            getClassName(): string;
    }
}

declare module 'babylonjs-editor/material-editor/material' {
    import { Scene, MaterialDefines, PushMaterial, Nullable, BaseTexture, Color3, Matrix, Vector2, Vector3, AbstractMesh, SubMesh, Mesh, IAnimatable, Effect } from 'babylonjs';
    /**
        * Custom Material class
        */
    export class CustomMaterialDefines extends MaterialDefines {
            TEXTURE: boolean;
            CLIPPLANE: boolean;
            ALPHATEST: boolean;
            DEPTHPREPASS: boolean;
            POINTSIZE: boolean;
            FOG: boolean;
            NORMAL: boolean;
            UV1: boolean;
            UV2: boolean;
            VERTEXCOLOR: boolean;
            VERTEXALPHA: boolean;
            NUM_BONE_INFLUENCERS: number;
            BonesPerMesh: number;
            INSTANCES: boolean;
            constructor();
    }
    /**
        * The custom material code interface which
        * comes from the user
        */
    export interface CustomMaterialCode {
            init: () => void;
            setUniforms: (uniforms: string[], samplers: string[]) => void;
            isReadyForSubMesh: (mesh: AbstractMesh, subMesh: SubMesh, defines: CustomMaterialDefines) => boolean;
            bindForSubMesh: (world: Matrix, mesh: Mesh, subMesh: SubMesh, effect: Effect) => void;
            dispose: () => void;
    }
    export interface CustomMaterialConfig {
            textures: {
                    name: string;
                    isCube: boolean;
            }[];
            floats: string[];
            vectors2: string[];
            vectors3: string[];
    }
    /**
        * Custom material class
        */
    export default class CustomEditorMaterial extends PushMaterial {
            baseColor: Color3;
            disableLighting: boolean;
            maxSimultaneousLights: number;
            _shaderName: string;
            userConfig: {
                    [index: string]: number | Vector2 | Vector3 | BaseTexture;
            };
            config: CustomMaterialConfig;
            customCode: CustomMaterialCode;
            _buildId: number;
            /**
                * Constructor
                * @param name: the name of the material
                * @param scene: the scene reference
                */
            constructor(name: string, scene: Scene, shaderName: string, customCode: CustomMaterialCode, config: CustomMaterialConfig);
            setCustomCode(customCode: CustomMaterialCode): void;
            needAlphaBlending(): boolean;
            needAlphaTesting(): boolean;
            getAlphaTestTexture(): Nullable<BaseTexture>;
            isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
            bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
            getAnimatables(): IAnimatable[];
            getActiveTextures(): BaseTexture[];
            hasTexture(texture: BaseTexture): boolean;
            dispose(forceDisposeEffect?: boolean): void;
            clone(name: string): CustomEditorMaterial;
            serialize(): any;
            getClassName(): string;
            static Parse(source: any, scene: Scene, rootUrl: string): CustomEditorMaterial;
    }
}

